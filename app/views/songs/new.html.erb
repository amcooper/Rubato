    <div class="container" style='margin-left: 16px;'>
      <div class="row" style='height: 800px; padding:0px;'>
        <div id="library"  class="col-2" >
          <% chords = Chord.all %>
          <% chords.each_with_index do  |chord, index| %>
            <p id="p<%= index %>" draggable="true" class="draggable rng" ondragstart="dragstart_handler(event)"><%= chord.name %></p>
          <% end %>
        </div>

<div class='col'>
        <div id="target-area" ondrop="drop_handler(event)" ondragover="dragover_handler(event)" style='position:relative'>

        </div>
<div style='width: 100%;'>
<span id="hide"></span>
<input id="txt" type="text" placeholder="Enter Lyrics">
<span class="stretcher" onmousedown="clickStretcher(event)" onmouseup="unclickStretcher(event)"><i class="fas fa-arrows-alt-h lyrics-handle-icon"></i></span>
</div>


</div>
      </div>

    </div>


  </div>

<script>
let numClones = 0
let currentDrag = null;
let offX = 0;
let textStartWidth = 150;
let textDefaultWidth = 150;
let letterSpacingStart = 1.0;
let wordSpacingStart = 1.0;

// const
const hide = document.getElementById('hide');
const txt = document.getElementById('txt');
// txt.style.maxWidth = '530px';
const ta = document.getElementById('target-area');

resize();
txt.addEventListener("input", resize);



document.addEventListener('mouseup', removeXListener, true);


function removeXListener (ev) {
  document.removeEventListener('mousemove', checkMouseX, true);
};



function clickStretcher (ev) {
  offX = (ev.clientX - parseInt(ev.target.getBoundingClientRect().x));
  textStartWidth = txt.style.width;
  currentDrag = ev.target;
  document.addEventListener('mousemove', checkMouseX, true);
}


function unclickStretcher (ev) {
  textStartWidth = txt.style.width;
  document.removeEventListener('mousemove', checkMouseX, true);
  currentDrag = null;

 letterSpacingStart = txt.style.letterSpacing;
 wordSpacingStart = txt.style.wordSpacing;
}



function checkMouseX(ev) {
  if (txt.value != "") {
    txt.style.width = (ev.screenX  - 150) - (ev.screenX - ev.clientX ) - (offX/2) + "px";

    txt.style.letterSpacing = letterSpacingStart + (parseInt(txt.style.width) - textDefaultWidth)/80  + 'px';
    hide.style.letterSpacing = letterSpacingStart + (parseInt(txt.style.width) - textDefaultWidth)/80  + 'px';

    txt.style.wordSpacing = wordSpacingStart + ((parseInt(txt.style.width) - textDefaultWidth)/25)  + 'px';
    hide.style.wordSpacing = wordSpacingStart + ((parseInt(txt.style.width) - textDefaultWidth)/25)  + 'px';

  }
  // currentDrag.style.display  = 'relative';
  // currentDrag.style.left  = (ev.screenX  - textStartWidth) + "px";

}


function resize() {
  hide.textContent = txt.value;
  txt.style.width = hide.offsetWidth + "px";
  textDefaultWidth  = hide.offsetWidth;
}

//  drag and drop  ////////////////////////////////////////
//////////////////////////////////////////////////////////

function dragstart_handler(ev) {

  ev.dataTransfer.setData("application/my-app", ev.target.id);
  ev.target.addEventListener("onMouseUp", dropChord(event), false);

  currentDrag = ev.target;
  if (currentDrag.parentNode.id == "target-area") {
    currentDrag.addEventListener('dragstart', handleDragStart, false);
    currentDrag.addEventListener('dragend', handleDragEnd, false);
  }
  function handleDragStart(e) {
    this.style.opacity = '0.3';
    this.style.transition = "opacity .5s";
  }


  function handleDragEnd(e) {
    this.style.opacity = '1';
    this.style.transition = "none";
  }

  function dropChord(event) {
      offX = event.offsetX;
  }
}

function dragover_handler(ev) {
  ev.preventDefault();
  const clones =  Array.from(document.getElementById('target-area').children);
  const sortedClones = clones.sort((a, b) => parseInt(a.style.left) - parseInt(b.style.left));
  let leftClones = [];
  let rightClones = [];
  sortedClones.forEach(function(element) {
      if (element != currentDrag) {
      if (parseInt(element.style.left) < parseInt(ev.clientX - ta.getBoundingClientRect().x)) {
        leftClones.unshift(element); // from center to left
      } else {
        rightClones.push(element); // from center to right
      }
    }
  });

  if (leftClones.length > 0) {
    if (dragIntersection(ev, leftClones[0]) == true ) {
      const overlap = leftOverlap(ev, leftClones[0]);
      rippleLeft(leftClones, overlap);
    }
  }

  if (rightClones.length > 0) {
    if (dragIntersection(ev, rightClones[0]) == true ) {
      console.log('riiiiiiight');
    }
  }



  // clones.forEach(function(element) {
  //   console.log(element.style.left);
  // if (element != currentDrag) {
  //   if (dragIntersection(ev, element, currentDrag) == true ) {
  //     const oldX = parseInt(element.style.left)
  //     let newX = oldX
  //     if (xOverlap(ev, element, currentDrag) > 0 ) {
  //       newX -= ((element.getBoundingClientRect().width) - xOverlap(ev, element, currentDrag) + 8) ;
  //       checkCollisionsLeft(element, clones);
  //     } else {
  //       newX += ((element.getBoundingClientRect().width) + xOverlap(ev, element, currentDrag)  + 8);
  //       checkCollisionsRight(element, clones);
  //     }
  //     if (newX < 0 || newX > element.parentNode.getBoundingClientRect().width - element.getBoundingClientRect().width) {
  //       replaceChord(element);
  //     };
  //     element.style.left = newX + 'px';
  //   }
  //   }
  // });
};


function rippleLeft(array, overlap) {
  let colliding = true;
  let ovr = overlap;
  for (i = 0; i < array.length - 1; i++) {
    const first = array[i];
    const second = array[i + 1];
    const oldX = parseInt(first.style.left);
    let newX = oldX - ovr;
    first.style.left = newX + 'px';

  }

}


function checkCollisionsLeft(el, clones) {
  clones.forEach(function(element) {
    if (element != el) {
      if (arrayLeftIntersection(el, element) == true ) {
        const oldX = parseInt(element.style.left);
        let newX = oldX - parseInt(arrayLeftOverlap(el, element)) ;
        checkArrayLeft(clones);
        // console.log("newX " + newX);
        if (newX < 0) {
          replaceChord(element);
        };
        element.style.left = newX + 'px';
      }
    }
  });
}


function checkCollisionsRight(el, clones) {
  clones.forEach(function(element) {
  if (element != el && element != currentDrag) {
      if (arrayRightIntersection(el, element) == true ) {
        const oldX = parseInt(element.style.left)
        let newX = oldX - parseInt(arrayRightOverlap(el, element)) ;
        checkArrayRight(clones);
        if (newX > element.parentNode.getBoundingClientRect().width - element.getBoundingClientRect().width) {
          replaceChord(element);
        };
        element.style.left = newX + 'px';
      }
    }
  });
}


function checkArrayLeft(clones) {
  clones.forEach(function(element1) {
  // if (element1 != currentDrag) {
    clones.forEach(function(element2) {
      if (element1 != element2) {
        if (arrayLeftIntersection(element1, element2) == true ) {
          const oldX = parseInt(element2.style.left);
          let newX = oldX - parseInt(arrayLeftOverlap(element1, element2));
          if (newX < 0) {
            // replaceChord(element2);
          };
          element2.style.left = newX + 'px';
        };
      };
    });
  // }
  });
};


function checkArrayRight(clones) {
  clones.forEach(function(element1) {
  // if (element1 != currentDrag) {
    clones.forEach(function(element2) {
      if (element1 != element2) {
        if (arrayRightIntersection(element1, element2) == true ) {
          const oldX = parseInt(element2.style.left);
          let newX = oldX - parseInt(arrayRightOverlap(element1, element2));
          if (newX < 0) {
            // replaceChord(element2);
          };
          element2.style.left = newX + 'px';
        };
      };
    });
  // }
  });
};



function drop_handler(ev) {

  ev.preventDefault();

  const data = ev.dataTransfer.getData("application/my-app");
  let el;
  const clone = document.getElementById(data).parentNode.id == "library" ? true : false;
  if (clone) {
    el  = document.getElementById(data).cloneNode([true]);
    el.id = "clone" + numClones;
    numClones ++ ;
    el.class = 'clone';
    el.insertAdjacentHTML("beforeend", '<div class="delete-chord" onclick="deleteChord(this)"><i class="fas fa-trash"></i></div> ')
  }  else {
    el  = document.getElementById(data);
  }
  ev.target.appendChild(el);
  el.style.position = 'absolute';
  el.style.left = ( (ev.screenX - window.screenX) - document.getElementById('target-area').parentNode.offsetLeft) - document.getElementById('target-area').offsetLeft - offX + "px";
}


function dragIntersection(ev, element) {
  return !(
    element.getBoundingClientRect().x > (ev.clientX - offX) + currentDrag.getBoundingClientRect().width ||
    element.getBoundingClientRect().x + element.getBoundingClientRect().width < (ev.clientX - offX)
  );
}

function arrayLeftIntersection(element1, element2) {
  return !(element2.getBoundingClientRect().x + element2.getBoundingClientRect().width < element1.getBoundingClientRect().x);
}


function arrayRightIntersection(element1, element2) {
  return !(element2.getBoundingClientRect().x  < element1.getBoundingClientRect().x + element1.getBoundingClientRect().width);
}


function arrayLeftOverlap(element1, element2) {
  return (((element2.getBoundingClientRect().x + element2.getBoundingClientRect().width) - element1.getBoundingClientRect().x)+ 16);
}

function arrayRightOverlap(element1, element2) {
  return (((element1.getBoundingClientRect().x + element1.getBoundingClientRect().width) - element2.getBoundingClientRect().x) + 16);
}


function leftOverlap(ev, element) {
    return ((element.getBoundingClientRect().x + element.getBoundingClientRect().width)) - (ev.clientX - offX);
}


function deleteChord(el) {
  const chord = (el.parentNode);
  chord.parentNode.removeChild(chord);
}

function replaceChord(el) {
  el.parentNode.removeChild(el);
}



</script>
