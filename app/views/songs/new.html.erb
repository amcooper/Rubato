<!DOCTYPE html>
<html>

<head>
  <title>Create New Song</title>


</head>
<body>
    <div class="container" style='margin-left: 16px;'>
      <div class="row" style='height: 800px; padding:0px;'>
        <div id="library"  class="col-2" >

        <% chords = Chord.all %>
        <% chords.each_with_index do  |chord, index| %>
          <p id="p<%= index %>" draggable="true" class="draggable rng" ondragstart="dragstart_handler(event)"><%= chord.name %></p>
        <% end %>
        </div>

        <div class='col-10' id="target-area" ondrop="drop_handler(event)" ondragover="dragover_handler(event)" style='position:relative'>

        </div>

      </div>

    </div>


  </div>
</body>

<script>

let currentDrag = null;
 // window.addEventListener('DOMContentLoaded', () => {

  let offX = 0;
  // });

 function dragstart_handler(ev) {

  ev.dataTransfer.setData("application/my-app", ev.target.id);
  ev.target.addEventListener("onMouseUp", dropChord(event), false);

  currentDrag = ev.target;
  function dropChord(event) {
      offX = event.offsetX;
  }
}

function dragover_handler(ev) {
 ev.preventDefault();
 const clones =  Array.from(document.getElementById('target-area').children);

 clones.forEach(function(element) {
  if (element != currentDrag) {
  if (haveIntersection(ev, element, currentDrag) == true ) {
      const oldPos = parseInt(element.style.left)
      let newPos = oldPos
    if (xOverlap(ev, element, currentDrag) > 0 ) {
      newPos -= ((element.getBoundingClientRect().width) - xOverlap(ev, element, currentDrag) + 8) ;
    } else {
      newPos += ((element.getBoundingClientRect().width) + xOverlap(ev, element, currentDrag)  + 8);
    }
     if (newPos < 0 || newPos > element.parentNode.getBoundingClientRect().width - element.getBoundingClientRect().width) {
        replaceChord(element);
     }
     ;
      element.style.left = newPos + 'px';
  }
  }
});
};

function drop_handler(ev) {

 ev.preventDefault();

 const data = ev.dataTransfer.getData("application/my-app");
 let el;
 const clone = document.getElementById(data).parentNode.id == "library" ? true : false;
 if (clone) {
  el  = document.getElementById(data).cloneNode([true]);
  el.id = "newId" + document.getElementById('target-area').children.length;
  el.class = 'clone';
  el.insertAdjacentHTML("beforeend", '<div class="delete-chord" onclick="deleteChord(this)">X</div> ')
 }  else {
  el  = document.getElementById(data);
 }
  ev.target.appendChild(el);
  el.style.position = 'absolute';
  el.style.left = ( (ev.screenX - window.screenX) - document.getElementById('target-area').offsetLeft) - offX + "px";
}


function haveIntersection(ev, element, currentDrag) {

  return !(
    element.getBoundingClientRect().x > (ev.clientX - offX) + currentDrag.getBoundingClientRect().width ||
    element.getBoundingClientRect().x + element.getBoundingClientRect().width < (ev.clientX - offX)
  );
}


function xOverlap(ev, element, currentDrag) {
    return ((ev.clientX - offX) - (element.getBoundingClientRect().x));
}


function deleteChord(el) {
  const chord = (el.parentNode);
  chord.parentNode.removeChild(chord);
}

function replaceChord(el) {
  el.parentNode.removeChild(el);
}



</script>
</html>

